# qiankun微前端原理介绍

## 什么是微前端

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。

我们先来粗略了解一下微前端项目的界面结构：

![简化图](./1.webp)

从上图可以明确地看到，微前端的主要布局可以分为三个部分：Header头部，菜单，以及子应用区域。

而我们要做的，就是通过切换菜单，然后再子应用区域切换为该菜单相应的子应用。

## 微前端的特点

* 技术栈独立 - 每个子应用都可以使用不同的框架、依赖等技术栈进行开发
* 独立开发，独立部署 - 每个子应用的仓库、开发、部署都是独立进行的，无需像其他web应用那样全量部署
* 沙箱隔离 - 每个应用之间的环境、状态、js、css相互隔离，运行时不共享不冲突

## 为什么不选择iframe

单看上面的概念和特点，有小伙伴可能会奇怪为什么不直接使用iframe，而是要搞那么多花里胡哨？

当然使用iframe也会有很多痛点，典型的有以下问题：

* url不同步 - iframe中的url与主体容器的url，这也意味着浏览器的前进后退无法直接响应iframe内的url
* DOM结构独立 - iframe与主体之间的DOM和JS脚本实则相互独立，最直接的例子就是假设从iframe的子模块中弹出一个带全局遮罩层的提示窗，显然它无法直接跨越iframe的界限展示在主体容器内
* 上下文隔离，全局环境和状态等不共享 - Cookie、LocalStrorage等或者其他一些状态值管理，除非处于同源，否则无法直接操作，当然也可以使用PostMessage处理这个问题，但这些方法不是效率不高就是具有局限性，特别是对于传递一些结构较为复杂的数据或直接传递一个函数的时候
* 同源策略问题 - 同源策略问题正如上一个痛点所说的，无疑加重了应用间的通信难度
* 加载缓慢 - 每个iframe实际上都是独立访问一个网站，访问多个网站的效率相比单独一个网站来说，显然是极其低效和不稳定的

问得好，其实确实有存在iframe的解决方案，那就是wujie。由于本次分享以qiankun为例，就不详细说wujie的解决这些问题的思路了，有兴趣的小伙伴可以自行去了解一下。

## qiankun的优势

| \          | qiankun                     | iframe                                     |
| ---------- | --------------------------- | ------------------------------------------ |
| 数据共享   | window                      | hash/query/LocalStorage(同源)/Cookie(同源) |
| 事件机制   | 私有通信机制                | PostMessage                                |
| 访问历史   | 全局统一，以主体容器url为准 | 主体容器及各应用各自隔离                   |
| 全局作用域 | 共享                        | 完全隔离                                   |
| CSS作用域  | 按需隔离                    | 完全隔离                                   |
| 资源价值   | 整体且快速，可预加载        | 独立且缓慢                                 |

qiankun在事件机制处理方式上，封装了一套私有的通信机制，各个应用间可通过封装好的API进行双向数据交互


* single-spa（单页应用）的路由会和ng重定向冲突

## JS沙箱

JS沙箱通过限制代码的访问权限、提供隔离的执行环境、使用安全策略和沙箱沙盒技术等手段来实现。常见的 JavaScript 沙箱技术包括沙盒环境、Web Worker、iframe、JavaScript 虚拟机等。这些技术通过限制代码的执行权限、提供独立的运行环境、隔离全局上下文等方式来确保代码的安全执行。

其中qiankun提供了以下三种沙箱：

### 快照沙箱-SnapshotSandbox

实现原理：

在激活沙箱时，window上发生改变的所有属性，全都储存起来，在下一次再次被激活时，复现这些已更改的属性、

而在失活状态时，则window中被改变的属性应该被还原为激活前的值。

可以用以下代码简单举个例子：

```js
// 沙箱激活前
window.test = '11111'
console.log(window.test)  // 11111

// 激活沙箱
sandbox.active()
window.test = '22222'
console.log(window.test)  // 22222

// 沙箱失活
sandbox.inactive()
console.log(window.test)  // 11111

// 再次激活沙箱
sandbox.active()
console.log(window.test)  // 22222
```

优点：

* 支持不兼容Proxy的浏览器，兼容性较好

缺点：

* 需要遍历window上所有属性，性能较差
* 同一时间只能用于一个应用，相当于仅能激活一个子应用
* 污染全局window，这也是造成上一个缺点的原因

### Legacy沙箱-LegacySandbox（单例）

功能实际上和快照沙箱相同，但过程是用Proxy实现的

优点：

* 采用Proxy代理属性，无需遍历window上所有属性，性能较好

缺点：

* 由于污染了全局window，因此同一时间依然只能运行一个子应用
* 兼容性相较差

### ProxySandbox 沙箱（多例）

原理是于contructor中以全局的window为原型创建一个fakeWindow对象，并采用Proxy代理这个对象，激活时使用的全程均不会污染全局window的属性，只有当读取属性值时，fakeWindow中未获取到相应对象的属性值才会去window中查找

优点：

* 采用Proxy代理属性，无需遍历window上所有属性，性能较好
* 不会污染全局window，因此能够支持多应用
* 应用/沙箱失活后，依然能够获取到其激活时发生改变的属性

缺点：

* 兼容性相较差

## 样式隔离

## 微前端运行原理

## qiankun的子应用引入

## 实践架构

![架构组成示意图](./2.webp)

从上图可以看出。我们将整个项目分为主应用、子应用，以及公共模块。

* 主应用：作为主容器和所有子应用和公共模块的调度官，负责注册子应用以及调度治理子应用功能
* 子应用：除了通过qiankun框架提供的状态管理器进行子应用间，或与主应用通讯外，基本上主要是对自己负责，负责内部具体业务逻辑
* 公共模块：负责在主应用中对应用鉴权，以及用户管理模块

其实可以看出，这个实践架构和我们目前基于Vue的新前端架构时非常相似的，包括主容器、子模块、公共模块等，基本都是一致的。只是区别在于微前端在划分、引入和打包主模块和子模块的流程和实现上的区别（当然这也是两者本质上的不同，最终效果也完全不一样）

https://zhuanlan.zhihu.com/p/546228614

https://juejin.cn/post/7242623208841592869#heading-15

https://www.jianshu.com/p/e8135c887bec
