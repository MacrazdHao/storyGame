# 前端架构概念分享

## 前端传统组成部分

### 原生代码

HTML+ JavaScript + CSS

微型项目或测试用项目首选，无需任何花里胡哨，干就完了，写完直接浏览器打开，简单粗暴。

### 经典的项目结构

```
- assets
- style
- js
- index.html
- ...pages
```

### 最原始的前端框架：jQuary

与其说是框架，不如说是代码库，它的宗旨是“write Less，Do More”。

封装了大量基于原生JavaScript和HTML相关API的实用函数，以及重写了很多更高效率的原生函数，且兼容性极强，下至IE6.0+，上至最新浏览器。

虽然已经接近被其他框架取代，但由于它的开源和轻量化，所以它仍然拥有少数老派公司在持续使用，同时也是一些小型HTML项目不错的选择，因此至今也是有不少受众，并且在不断迭代的。

### ECMAScript6+

ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。(来源百度)

目前市面上最主流的版本是ES5和ES6，ES6是基于ES5后的一次主要改进，添加了很多必要和更实用的特性，甚至支持了向面向对象靠拢的Class语法糖。

现在已经更新带了ES14(2023)，具体的有兴趣可以直接查阅相关文档，就不一一介绍特性了。

对于ES6后的版本由于兼容性文婷并不推荐使用，如果一定要使用，建议务必引入babel去降级编译为成ES5或ES6。

与Webpack两者都是现代Web开发极其重要的工具。

#### babel

用于将ES6+的JavaScript代码转换为向后兼容的版本的工具。

通常与Webpack等HTML打包工具一并使用。

### 动态网站

在前后端分离的概念提出前，行业内普遍流行的开发模式。

#### ASP

已被淘汰的服务端动态网页技术。

#### JSP

相信学习过Java服务端的多多少少都了解或使用过，JSP基于Java的服务端动态页面的网站脚本语言，能够迁入Java代码块等使其页面能与服务端的数据进行交互，在用户访问时，服务端将JSP解析为Java Servlet，并生成HTML返回给浏览器，从而达成动态页面的效果。

虽然目前面临被淘汰的局面，但仍有不少老派企业在使用（主要是年代较久的老项目维护）。

#### PHP

PHP是世界上最好的语言，相信大家对这句话已经听得耳朵起茧了。

PHP类似JSP，它也属于在服务端执行的脚本语言，作用原理也是在服务端解析，最终转译为HTML返回给发起请求的浏览器。

由于它多方面的优点，如能够在大多数操作系统运行、易学易用、支持面向对象、高性能、应用广等，因此至今仍有大量开发者在使用，也特别适用于中小型Web项目。

### 打包工具

主要流行的打包工具有webpack、gulp、grunt、Rollup等。

打包工具的出现与日益复杂的Web应用配置和资源、前后端分离概念的兴起等原因有关，随之应运而生。

它能够帮助Web应用开发者更加快速便捷地配置Web应用，减少了大量手动配置资源的步骤和构建流程，同时还提供了自动优化、压缩、静态资源转换、环境和规则管理等强大功能。

不得不说，把Webpack称为Web应用的前端划时代的大发明也不为过。

## 前端架构设计模式

### MVC

是一种最早提出的基于分层的设计模式，相信大家对它已经很熟悉，它将应用程序分为三个部分：模型（Model），视图（View）和控制器（Controller）。其中，模型负责处理数据的逻辑操作，视图负责展现数据和用户界面，控制器则作为中间层来将模型和视图连接起来，并负责处理用户输入等操作。通过MVC的合理使用，可以使应用程序的各个部分显得更加清晰，易于维护和扩展。

view可以通过model和controller获得数据，view与controller是一对多的关系。

应用：Struts、.NET等

### MVP

与MVC相似，但注重于区分展示逻辑和业务逻辑，它将控制器(C)分解为视图和控制逻辑之间新的Presenter(展示器)层，并将数据交给Presenter处理，从而实现更高级的单元测试和灵活性。

Presenter(展示器)层：展示器被添加到MVP架构中，它是连接Model和View的桥梁，处理所有视图相关的逻辑操作和事件，更新视图实现数据的展示，并响应用户交互事件并将其发送给Model进行处理。

view只可以用过Presenter获得数据，view与Presenter是一对一的关系。

应用：Android等

### MVVM

是一种相对较新的设计模式，它在MVC模式的基础上进一步扩展了视图控制。在这个模式中，ViewModel 的作用类似于控制器，管理着视图和模型之间的通信逻辑。ViewModel还提供了数据绑定功能，它将视图和模型的数据保持同步，使程序员无需手动更新数据。因此，MVVM可以更好地支持现代化的前端开发，特别是SPA（单页应用）等复杂的多页面应用程序是非常适用的。

其中Vue正是采用了MVVM设计模式，其2.x版本ViewModel层的实现则是使用发布订阅模式实现。

### Flux

结合React使用的一种数据流设计模式,整个应用程序的状态保存在一个中央存储区(store)中，并通过“单向数据流”（unidirectional data flow）来管理应用程序状态的修改，并通知各个订阅者进行更新。常见的Flux实现是Redux。

### 其他

Micro frontends、CQRS等，因较为少见没有专门去关注，有兴趣可以自行搜索了解。

## 现代前端

### 我常用的前端项目结构

对于我目前接手过的所有项目(包括Vue、React Native、小程序等)，所采用的目录结构，均能大致按照各自的用处作为依据，划分为下六个部分组成：

* 页面 - 为提高代码复用性，通常又细分为 容器、内容、组件、样式 四个部分
* 数据 - 又分为 获取(请求)、存储 两个部分
* 路由
* 通用 - 包含 通用的工具类函数(utils)、静态资源(assets)
* 打包配置
* 第三方内容 - 如 i18n国际化 等

包括目前组内在用的前端新架构，也是基于此的灵活运用。

以此为例，主模块包含了所有子模块通用的组件、数据、工具函数、打包配置、第三方内容、路由，而主模的页面部分则细分为子模块来充当。

子模块的主要内容也因此是页面了，但针对子模块内部的页面，也包含局部独立的组件、数据、工具函数、第三方内容、路由的子内容。

大家有兴趣可以根据这一脉络可以自己线下分析一下现有的前端项目。

### 现代前端主要架构组成

#### 前后端分离

现代前端主流的Web应用开发体系，随着前端业务的需求和资源等越来越多且复杂，对此服务端的压力也逐渐增大，逐渐地这个概念就被正式提出，很多的前端相关的业务内容不再依附于服务端，而是成为独立的部分，并由独立的前端开发进行维护。

##### 优势

分工明确，效率显著，代码复用率更高，UI及交互呈现能力提高。

##### 面临的挑战

虽然在技术层面得到了优化，但是在现实层面来讲同时也产生了另一个问题，那就是沟通问题。前后端的技术栈本身就是不同的技术类型和方向，加上沟通作为人为因素，自然是成为了前后端分离难以控制的弊端之一。

即便针对该问题，各界大佬也提出了各种约束性的协议，例如Rustful等等，也还是难以杜绝相关问题。

这也是本次分享主题的核心，为了加强前后端之间的联合开发和工作，增进互相了解是非常有必要的。

话说合久必分，分久必合，现如今全栈工程师也因此慢慢又再次流行了起来。

### 主流前后端分离的前端框架

主流的就是Vue、React、Angular三个前端框架，除此之外还有各个平台的小程序等等H5应用，也基本均是基于前后端分离的概念应运而生的。

### 跨平台解决方案

目前，除了专门的三大前端框架外，还有不少跨平台解决方案也是雨后春笋般陆续出现，旨在一套代码，到处部署，即提高代码复用率，以及UI的的统一性，像React Native、Flutter、Electron、Weex等。

### SSR - 服务端渲染

是客户端和服务器端协作完成页面生成和显示的一种技术方案。传统Web应用中，页面内容的生成主要由浏览器端完成，即先下载HTML、CSS等文件，再执行JS脚本并发送请求获取数据更新DOM上的内容；但随着前端项目的变复杂、交互行为更加丰富，这种方式会导致首屏加载缓慢、SEO不友好等问题，因此出现了以服务器渲染的需求。

而 SSR 则通过在服务器端编译生成 HTML、CSS 和 JS 文件，先将初始页面展现内容直接封装到模板当中，再将数据传输给浏览器。在客户端浏览器发起请求时，浏览器同样可以解析JavaScript代码，然后与服务器端的动态数据进行结合，二次更新构建到HTML DOM，可能消除大量额外网络请求同时保证用户能够很快看到页面内容。

简而言之，SSR实现了在服务端将静态资源与动态数据组装成一个完整的HTML文档，再将其发送给浏览器，使浏览器有较少的工作量和更快的浏览体验。

### 微前端概念

用一个index.html集成并按需加载页面各个模块化的部分的包

微前端是一种架构风格，旨在将单个Web应用程序拆分成小型、可独立开发、部署和维护的多个部分（也称为微前端），从而实现更好的可扩展性和灵活性。

微前端原理主要包括以下几个方面：

模块化：采用ES Module进行模块化管理，实现了每个子应用的独立打包、独立发布、独立运行。

应用隔离：每个子应用都工作在自己的沙箱环境，保证了各个模块之间的隔离性，避免了全局变量污染和样式冲突等问题。

动态接入：可以通过动态加载脚本与样式来实现各个微应用的按需加载，降低首屏加载时间。

路由共享：通过路由映射机制，可以将所有子应用整合在同一个容器里面，共享同一个路径下的资源和参数。

状态共享：可以通过缓存或者后台服务通知的方式实现状态共享，以此可以实现共享各个微应用的用户信息、购物车等状态。

无感知更新：可以通过版本控制机制实现微应用的自动化部署，从而实现无缝更新。