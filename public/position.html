<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <!-- <link rel="icon" href="<%= BASE_URL %>favicon.ico" /> -->
  <title>飞机</title>
</head>
<style>
  html {
    width: 100%;
    height: 100%;
  }

  body {
    width: calc(100vw - 0px);
    height: 100vh;
    transform: scale(1);
    display: flex;
    flex-direction: row;
    position: relative;
    /* flex-wrap: wrap; */
    /* margin-left: 50px;
    margin-top: 20px; */
  }

  * {
    padding: 0;
    margin: 0;
    box-sizing: border-box;
  }

  .block {
    /* box-sizing: border-box; */
    /* border: 1px solid #000; */
    /* background-color: #fff; */
    /* position: absolute; */
    transition: 0.3s all;
  }

  .crashTips {
    color: #f00;
    position: fixed;
    top: -60px;
    left: 50%;
    width: fit-content;
    height: fit-content;
    /* translate: calc(-50%, -50%); */
    font-size: 30px;
    font-weight: bold;
    white-space: nowrap;
  }

  .blockRow {
    height: 100%;
    width: fit-content;
    display: flex;
    flex-direction: column;
  }
</style>

<body>
  <div class="blockRow" style="display: none;"></div>
  <div class="block" style="display: none"></div>
  <p class="crashTips"></p>
</body>
<script>
  const crashTipsDom = document.getElementsByClassName('crashTips')[0]
  let WindowWidth = document.body.offsetWidth
  let WindowHeight = document.body.offsetHeight
  let WindowArea = WindowWidth * WindowHeight
  let WindowProportion = WindowWidth / WindowHeight
  const ScreenScale = 1
  const BlockRowProto = document.getElementsByClassName("blockRow")[0]
  const ScreenDom = document.getElementsByTagName("body")[0]
  const ScreenRect = ScreenDom.getBoundingClientRect()
  const BlockProto = document.getElementsByClassName("block")[0]
  // {id, blockDom, originColor, objectsId, objectColors}
  let Blocks = {}
  const BlockNum = 10000 // 只是大概，若有剩余则会向下取整
  let PosProportion = Math.sqrt(BlockNum / WindowArea)
  let ScreenRowBlockNum = Math.floor(PosProportion * WindowWidth)
  let ScreenColumnBlockNum = Math.floor(PosProportion * WindowHeight)
  let RealPosProportion = Math.sqrt(ScreenRowBlockNum * ScreenColumnBlockNum / WindowArea)
  let BlockWidth = Math.floor(WindowWidth / ScreenRowBlockNum)
  let BlockHeight = Math.floor(WindowHeight / ScreenColumnBlockNum)

  let WindowForScreenMinX = ScreenRect.left
  let WindowForScreenMinY = ScreenRect.top
  let WindowForScreenMaxX = ScreenRect.left + BlockWidth * ScreenRowBlockNum
  let WindowForScreenMaxY = ScreenRect.top + BlockHeight * ScreenColumnBlockNum

  const BlackColor = '#fff'
  const WhiteColor = '#fff'
  const MouseObjectName = 'mouse'
  let MouseObjectId = ''
  const ObjectsProto = {
    mouse: {
      zIndex: 100,
      centerRelativePos: { x: 1, y: 2 }, // 坐标从0起数，相对图形本身的宫格内的坐标
      coverRelativeRowPosStr: ['01010', '11111', '01110', '00100'],  // 5*5宫格
      color: '#f00',
      crashCallback: function (crashObjKey) {
        console.log(`${this.id}: ${crashObjKey}和我碰撞了`)
      },
    },
    test1: {
      zIndex: 99,
      centerRelativePos: { x: 1, y: 2 }, // 坐标从0起数，相对图形本身的宫格内的坐标
      coverRelativeRowPosStr: ['01010', '11111', '01110', '00100'],  // 5*5宫格
      color: '#00f',
      crashCallback: function (crashObjKey) {
        console.log(`${this.id}: ${crashObjKey}和我碰撞了`)
      },
    }
  }
  const Objects = {}
  let ObjectsLightMap = {}

  // 构建物体对象
  const createObject = (objName) => {
    const id = `${objName}_${Math.random().toString(36).slice(2)}`
    Objects[id] = {
      ...JSON.parse(JSON.stringify(ObjectsProto[objName])),
      id,
      currentCenterPosKey: '',
      lightingPos: [], // ["x_y", ...]
      crashObjects: {},
    }
    crashCallback = (crashObjKey) => {
      ObjectsProto[objName].crashCallback.call(Objects[id], crashObjKey)
    }
    Objects[id].crashCallback = crashCallback
    return id
  }
  // 从coverRelativeRowPosStr获取相对图形中心centerRelativePos的相对坐标
  const getObjectRelativePos = (objId) => {
    const { centerRelativePos, coverRelativeRowPosStr } = Objects[objId]
    const centerX = centerRelativePos.x
    const centerY = centerRelativePos.y
    const lightPos = []
    const centerPos = { x: 0, y: 0 }
    for (let r = 0; r < coverRelativeRowPosStr.length; r++) {
      const col = coverRelativeRowPosStr[r].split('')
      for (let c = 0; c < col.length; c++) {
        const x = c - centerY
        const y = r - centerX
        // 列 = x , 行 = y
        if (col[c] === '1') lightPos.push({ x, y })
      }
    }
    return lightPos
  }
  // 获取像素块当前应该展示的颜色
  const getBlockColor = (pos) => {
    const { originColor, objectsId } = Blocks[pos]
    let bcolor = originColor
    let zi = 0
    for (let okey in objectsId) {
      if (objectsId[okey]) {
        const { zIndex, color } = Objects[okey]
        if (zIndex > zi) {
          zi = zIndex
          bcolor = color
        }
      }
    }
    return bcolor
  }
  // 清除物体移动后已失去的像素块的颜色
  const clearObjectLightingPos = (objKey, ignorePos = {}) => {
    // ignorePos为可忽略的点集合，减少需要处理的像素块，提高像素块处理的精确度
    Objects[objKey].lightingPos = Objects[objKey].lightingPos.filter(pos => {
      if (ignorePos[pos]) return true
      let { blockDom, originColor, objectColors } = Blocks[pos]
      Blocks[pos].objectsId[objKey] = false
      blockDom.style.backgroundColor = getBlockColor(pos)
      return false
    })
  }
  // 基于单个像素块的碰撞检测
  const crashCheck = (objKey, pos) => {
    const { objectsId } = Blocks[pos]
    const crashObjectsKey = []
    // 遍历占有当前像素格的物体标记
    for (let okey in objectsId) {
      // 跳过自身
      if (okey === objKey) continue
      // 当前像素格内的该物体标记为true
      if (objectsId[okey]) {
        // hasCrash为true，表示拥有碰撞物体
        hasCrash = true
        crashObjectsKey.push(okey)
        continue
      }
      // 当前物体未碰撞
      // Objects[objKey].crashObjects[okey] = false
    }
    return crashObjectsKey
  }
  // 渲染物体所占的像素块
  const lightObjectBlock = (objKey, pos) => {
    const { color, zIndex, currentCenterPosKey, centerRelativePos } = Objects[objKey]
    const lightPos = getObjectRelativePos(objKey)
    const centerPosKey = `${pos.x - centerRelativePos.x}_${pos.y - centerRelativePos.y}`
    if (currentCenterPosKey === centerPosKey) return
    Objects[objKey].currentCenterPosKey = centerPosKey
    const clearIgnorePos = {}
    const crashObjectsKey = new Set()
    // 点亮像素块，遍历每个像素块的碰撞情况
    lightPos.forEach(rpos => {
      const lightX = pos.x + rpos.x
      const lightY = pos.y + rpos.y
      const blockPos = `${lightX}_${lightY}`
      if (Blocks[blockPos]) {
        const { blockDom } = Blocks[blockPos]
        Blocks[blockPos].objectsId[objKey] = true
        blockDom.style.backgroundColor = getBlockColor(blockPos)
        Objects[objKey].lightingPos.push(blockPos)
        clearIgnorePos[blockPos] = true
        crashCheck(objKey, blockPos).forEach(item => crashObjectsKey.add(item))
      }
    })
    clearObjectLightingPos(objKey, clearIgnorePos)
    const { crashObjects, crashCallback } = Objects[objKey]
    crashObjectsKey.forEach(okey => {
      if (!crashObjects[okey]) {
        const _crashCallback = Objects[okey].crashCallback
        crashCallback(okey)
        _crashCallback(objKey)
      }
      Objects[objKey].crashObjects[okey] = true
    })
    for (let okey in Objects[objKey].crashObjects) {
      Objects[objKey].crashObjects[okey] = crashObjectsKey.has(okey)
    }
  }
  // 清空Screen
  const clearScreen = () => {
    for (let key in Blocks) {
      Blocks[key].blockDom.remove()
    }
    Blocks = {}
  }
  // 创建screen
  const createScreen = () => {
    clearScreen()
    WindowWidth = document.body.offsetWidth
    WindowHeight = document.body.offsetHeight
    WindowArea = WindowWidth * WindowHeight
    WindowProportion = WindowWidth / WindowHeight
    PosProportion = Math.sqrt(BlockNum / WindowArea)
    ScreenRowBlockNum = Math.floor(PosProportion * WindowWidth)
    ScreenColumnBlockNum = Math.floor(PosProportion * WindowHeight)
    RealPosProportion = Math.sqrt(ScreenRowBlockNum * ScreenColumnBlockNum / WindowArea)
    BlockWidth = (WindowWidth / ScreenRowBlockNum)
    BlockHeight = (WindowHeight / ScreenColumnBlockNum)
    // console.log(WindowWidth, WindowHeight)
    // console.log(ScreenColumnBlockNum, ScreenRowBlockNum)
    // console.log(BlockWidth, BlockHeight)
    // console.log(BlockWidth*ScreenRowBlockNum, BlockHeight*ScreenColumnBlockNum)
    for (let r = 0; r < ScreenRowBlockNum; r++) {
      const colDom = BlockRowProto.cloneNode(true)
      colDom.style.display = "flex"
      for (let c = 0; c < ScreenColumnBlockNum; c++) {
        const BlockItem = BlockProto.cloneNode(true)
        BlockItem.style.width = `${BlockWidth}px`
        BlockItem.style.height = `${BlockHeight}px`
        BlockItem.style.display = `block`
        let originColor = ''
        if (c % 2) {
          if (r % 2) originColor = BlackColor
          else originColor = WhiteColor
        } else {
          if (r % 2) originColor = WhiteColor
          else originColor = BlackColor
        }
        BlockItem.style.backgroundColor = originColor
        const id = `${r}_${c}`
        BlockItem.setAttribute("id", id)
        Blocks[id] = {
          id,
          blockDom: BlockItem,
          originColor,
          objectsId: { ...ObjectsLightMap }
        }
        colDom.appendChild(BlockItem)

        // BlockItem.style.top = `${c * BlockWidth}px`
        // BlockItem.style.left = `${r * BlockHeight}px`
        // document.body.appendChild(BlockItem)
      }
      document.body.appendChild(colDom)
    }
    WindowForScreenMinX = ScreenRect.left
    WindowForScreenMinY = ScreenRect.top
    WindowForScreenMaxX = ScreenRect.left + BlockWidth * ScreenRowBlockNum
    WindowForScreenMaxY = ScreenRect.top + BlockHeight * ScreenColumnBlockNum
  }

  // window坐标转换为screen坐标
  const translatePos = (pos, reverse = false) => {
    if (reverse) {
      return { x: (pos.x + 1) * (BlockWidth * ScreenScale) + ScreenRect.left, y: (pos.y + 1) * (BlockHeight * ScreenScale) + ScreenRect.top }
    }
    return { x: Math.ceil((pos.x - ScreenRect.left) / (BlockWidth * ScreenScale)) - 1, y: Math.ceil((pos.y - ScreenRect.top) / (BlockHeight * ScreenScale)) - 1 }
  }
  // 绘制物体
  const drawObject = (objectKey, e) => {
    const { x, y } = translatePos(e)
    const pos = `${x}_${y}`
    const block = Blocks[pos]
    if (!block) return
    const { id, centerRelativePos, coverRelativeRowPosStr, color } = Objects[MouseObjectId]
    lightObjectBlock(objectKey, { x, y })
  }
  // 获取一个Screen范围内的相对Screen的坐标
  const getRandomPos = () => {
    return { x: WindowForScreenMinX + Math.random() * (WindowForScreenMaxX - WindowForScreenMinX), y: WindowForScreenMinY + Math.random() * (WindowForScreenMaxY - WindowForScreenMinY) }
  }

  // 将坐标Key转换为坐标 "x_y" => {x, y}
  const getPosFromPosKey = (posKey = '') => {
    const arr = posKey.split('_')
    return { x: parseInt(arr[0]), y: parseInt(arr[1]) }
  }
  // 获取物体中心的相对Screen的坐标
  const getObjectCenterPos = (objKey) => {
    return getPosFromPosKey(Objects[objKey].currentCenterPosKey)
  }

  // 八个方向的相对移动单位坐标
  // ↖ ↑ ↗ ← → ↙ ↓ ↘
  const moveSides = [{ x: -0.5, y: 0.5 }, { x: 0.5, y: 0.5 }, { x: 1.5, y: 0.5 }, { x: -0.5, y: 1.5 }, { x: 1.5, y: 1.5 }, { x: -0.5, y: 2.5 }, { x: 0.5, y: 2.5 }, { x: 2, y: 2.5 }]
  // 获取一个随机方向的相对Window的移动坐标
  const getOneRandomSidePos = (objKey) => {
    const randomSide = moveSides[Math.floor(Math.random() * moveSides.length)]
    // const randomSide = moveSides[3]
    let { x, y } = getObjectCenterPos(objKey)
    return translatePos({ x: x + randomSide.x, y: y + randomSide.y }, true)
  }
  // 物体随机移动一个方向的单位坐标
  const randomMoveObject = (objKey) => {
    setInterval(() => {
      const e = getOneRandomSidePos(objKey)
      console.log(getObjectCenterPos(objKey), e)
      drawObject(objKey, e)
    }, 1000)
  }

  createScreen()
  MouseObjectId = createObject(MouseObjectName)
  // 普通物体创建与移动
  const test1 = createObject('test1')
  drawObject(test1, getRandomPos())
  randomMoveObject(test1)

  window.addEventListener('resize', createScreen)
  window.addEventListener('mousemove', (e) => drawObject(MouseObjectId, e))
</script>

</html>