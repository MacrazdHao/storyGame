<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <!-- <link rel="icon" href="<%= BASE_URL %>favicon.ico" /> -->
  <title>飞机</title>
</head>
<style>
  html {
    width: 100%;
    height: 100%;
  }

  body {
    width: calc(100vw - 0px);
    height: 100vh;
    transform: scale(1);
    display: flex;
    flex-direction: row;
    position: relative;
    /* flex-wrap: wrap; */
    /* margin-left: 50px;
    margin-top: 20px; */
  }

  * {
    padding: 0;
    margin: 0;
    box-sizing: border-box;
  }

  .block {
    /* box-sizing: border-box; */
    /* border: 1px solid #000; */
    /* background-color: #fff; */
    /* position: absolute; */
  }

  .crashTips {
    color: #f00;
    position: fixed;
    top: -60px;
    left: 50%;
    width: fit-content;
    height: fit-content;
    /* translate: calc(-50%, -50%); */
    font-size: 30px;
    font-weight: bold;
    white-space: nowrap;
  }

  .blockRow {
    height: 100%;
    width: fit-content;
    display: flex;
    flex-direction: column;
  }
</style>

<body>
  <div class="blockRow" style="display: none;"></div>
  <div class="block" style="display: none"></div>
  <p class="crashTips"></p>
</body>
<script>
  const crashTipsDom = document.getElementsByClassName('crashTips')[0]
  let WindowWidth = document.body.offsetWidth
  let WindowHeight = document.body.offsetHeight
  let WindowArea = WindowWidth * WindowHeight
  let WindowProportion = WindowWidth / WindowHeight
  const ScreenScale = 1
  const BlockRowProto = document.getElementsByClassName("blockRow")[0]
  const ScreenDom = document.getElementsByTagName("body")[0]
  const ScreenRect = ScreenDom.getBoundingClientRect()
  const BlockProto = document.getElementsByClassName("block")[0]
  // {id, blockDom, originColor, objectsId, objectColors}
  let Blocks = {}
  const BlockNum = 1000 // 只是大概，若有剩余则会向下取整
  let PosProportion = Math.sqrt(BlockNum / WindowArea)
  let ScreenRowBlockNum = Math.floor(PosProportion * WindowWidth)
  let ScreenColumnBlockNum = Math.floor(PosProportion * WindowHeight)
  let RealPosProportion = Math.sqrt(ScreenRowBlockNum * ScreenColumnBlockNum / WindowArea)
  let BlockWidth = Math.floor(WindowWidth / ScreenRowBlockNum)
  let BlockHeight = Math.floor(WindowHeight / ScreenColumnBlockNum)

  let WindowForScreenMinX = ScreenRect.left
  let WindowForScreenMinY = ScreenRect.top
  let WindowForScreenMaxX = ScreenRect.left + BlockWidth * ScreenRowBlockNum
  let WindowForScreenMaxY = ScreenRect.top + BlockHeight * ScreenColumnBlockNum

  const BlackColor = '#000'
  const WhiteColor = '#fff'
  const MouseObjectKey = 'mouse'
  const Objects = {
    mouse: {
      id: 'mouse',
      zIndex: 100,
      currentCenterPosKey: '',
      centerRelativePos: { x: 1, y: 2 }, // 坐标从0起数，相对图形本身的宫格内的坐标
      coverRelativeRowPosStr: ['01010', '11111', '01110', '00100'],  // 5*5宫格
      lightingPos: [], // ["x-y", ...]
      color: '#f00'
    },
    test1: {
      id: 'test1',
      zIndex: 99,
      currentCenterPosKey: '',
      centerRelativePos: { x: 1, y: 2 }, // 坐标从0起数，相对图形本身的宫格内的坐标
      coverRelativeRowPosStr: ['01010', '11111', '01110', '00100'],  // 5*5宫格
      lightingPos: [], // ["x-y", ...]
      color: '#00f'
    },
  }
  let ObjectsLightMap = {}
  Object.keys(Objects).forEach(okey => {
    ObjectsLightMap[okey] = false
  })

  const getObjectRelativePos = (objId) => {
    const { centerRelativePos, coverRelativeRowPosStr } = Objects[objId]
    const centerX = centerRelativePos.x
    const centerY = centerRelativePos.y
    const lightPos = []
    const centerPos = { x: 0, y: 0 }
    for (let r = 0; r < coverRelativeRowPosStr.length; r++) {
      const col = coverRelativeRowPosStr[r].split('')
      for (let c = 0; c < col.length; c++) {
        const x = c - centerY
        const y = r - centerX
        // 列 = x , 行 = y
        if (col[c] === '1') lightPos.push({ x, y })
      }
    }
    return lightPos
  }

  const getBlockColor = (pos) => {
    const { originColor, objectsId } = Blocks[pos]
    let bcolor = originColor
    let zi = 0
    for (let okey in objectsId) {
      if (objectsId[okey]) {
        const { zIndex, color } = Objects[okey]
        if (zIndex > zi) {
          zi = zIndex
          bcolor = color
        }
      }
    }
    return bcolor
  }

  const clearObjectLightingPos = (objKey) => {
    Objects[MouseObjectKey].lightingPos = Objects[objKey].lightingPos.filter(pos => {
      let { blockDom, originColor, objectColors } = Blocks[pos]
      Blocks[pos].objectsId[objKey] = false
      blockDom.style.backgroundColor = getBlockColor(pos)
      return false
    })
  }

  const crashCheck = (objKey, pos) => {
    const { objectsId } = Blocks[pos]
    let hasCrash = false
    for (let okey in objectsId) {
      if (okey === objKey) continue
      if (objectsId[okey]) {
        // crashTipsDom.innerHTML = `${objKey}和${okey}碰撞了`
        // setTimeout(() => {
        //   crashTipsDom.innerHTML = ""
        // }, 1000)
        console.log(`${objKey}和${okey}碰撞了`)
        hasCrash = true
        break
      }
    }
    return hasCrash
  }

  const lightObjectBlock = (objKey, pos) => {
    const { color, zIndex, currentCenterPosKey, centerRelativePos } = Objects[objKey]
    const lightPos = getObjectRelativePos(objKey)
    const centerPosKey = `${pos.x - centerRelativePos.x}-${pos.y - centerRelativePos.y}`
    if(currentCenterPosKey === centerPosKey) return
    Objects[objKey].currentCenterPosKey = centerPosKey
    clearObjectLightingPos(objKey)
    let crashChecked = false
    lightPos.forEach(rpos => {
      const lightX = pos.x + rpos.x
      const lightY = pos.y + rpos.y
      const blockPos = `${lightX}-${lightY}`
      if (Blocks[blockPos]) {
        const { blockDom } = Blocks[blockPos]
        Blocks[blockPos].objectsId[objKey] = true
        blockDom.style.backgroundColor = getBlockColor(blockPos)
        Objects[objKey].lightingPos.push(blockPos)
        if (!crashChecked) crashChecked = crashCheck(objKey, blockPos)
      }
    })
  }

  const clearScreen = () => {
    for (let key in Blocks) {
      Blocks[key].blockDom.remove()
    }
    Blocks = {}
  }

  const createScreen = () => {
    clearScreen()
    WindowWidth = document.body.offsetWidth
    WindowHeight = document.body.offsetHeight
    WindowArea = WindowWidth * WindowHeight
    WindowProportion = WindowWidth / WindowHeight
    PosProportion = Math.sqrt(BlockNum / WindowArea)
    ScreenRowBlockNum = Math.floor(PosProportion * WindowWidth)
    ScreenColumnBlockNum = Math.floor(PosProportion * WindowHeight)
    RealPosProportion = Math.sqrt(ScreenRowBlockNum * ScreenColumnBlockNum / WindowArea)
    BlockWidth = (WindowWidth / ScreenRowBlockNum)
    BlockHeight = (WindowHeight / ScreenColumnBlockNum)
    // console.log(WindowWidth, WindowHeight)
    // console.log(ScreenColumnBlockNum, ScreenRowBlockNum)
    // console.log(BlockWidth, BlockHeight)
    // console.log(BlockWidth*ScreenRowBlockNum, BlockHeight*ScreenColumnBlockNum)
    for (let r = 0; r < ScreenRowBlockNum; r++) {
      const colDom = BlockRowProto.cloneNode(true)
      colDom.style.display = "flex"
      for (let c = 0; c < ScreenColumnBlockNum; c++) {
        const BlockItem = BlockProto.cloneNode(true)
        BlockItem.style.width = `${BlockWidth}px`
        BlockItem.style.height = `${BlockHeight}px`
        BlockItem.style.display = `block`
        let originColor = ''
        if (c % 2) {
          if (r % 2) originColor = BlackColor
          else originColor = WhiteColor
        } else {
          if (r % 2) originColor = WhiteColor
          else originColor = BlackColor
        }
        BlockItem.style.backgroundColor = originColor
        const id = `${r}-${c}`
        BlockItem.setAttribute("id", id)
        Blocks[id] = {
          id,
          blockDom: BlockItem,
          originColor,
          objectsId: { ...ObjectsLightMap }
        }
        colDom.appendChild(BlockItem)

        // BlockItem.style.top = `${c * BlockWidth}px`
        // BlockItem.style.left = `${r * BlockHeight}px`
        // document.body.appendChild(BlockItem)
      }
      document.body.appendChild(colDom)
    }
    WindowForScreenMinX = ScreenRect.left
    WindowForScreenMinY = ScreenRect.top
    WindowForScreenMaxX = ScreenRect.left + BlockWidth * ScreenRowBlockNum
    WindowForScreenMaxY = ScreenRect.top + BlockHeight * ScreenColumnBlockNum
  }

  // screen相对Windows的位置
  const getRelativePos = (pos) => {
    const scaleXDist = WindowWidth * (1 - ScreenScale) / 2
    const scaleYDist = WindowHeight * (1 - ScreenScale) / 2
    return { x: pos.x - ScreenRect.left, y: pos.y - ScreenRect.top }
  }

  const translatePos = (pos) => {
    const { x, y } = getRelativePos(pos)
    return { x: Math.ceil(x / (BlockWidth * ScreenScale)) - 1, y: Math.ceil(y / (BlockHeight * ScreenScale)) - 1 }
  }

  const drawBlock = (objectKey, e) => {
    const { x, y } = translatePos(e)
    const pos = `${x}-${y}`
    const block = Blocks[pos]
    if (!block) return
    const { id, centerRelativePos, coverRelativeRowPosStr, color } = Objects[MouseObjectKey]
    lightObjectBlock(objectKey, { x, y })
  }

  const getRandomPos = () => {
    return { x: WindowForScreenMinX + Math.random() * (WindowForScreenMaxX - WindowForScreenMinX), y: WindowForScreenMinY + Math.random() * (WindowForScreenMaxY - WindowForScreenMinY) }
  }

  const insertObject = (objKey, pos) => {
    drawBlock(objKey, pos)
  }

  createScreen()
  drawBlock('test1', getRandomPos())
  window.addEventListener('resize', createScreen)
  window.addEventListener('mousemove', (e) => drawBlock(MouseObjectKey, e))
</script>

</html>